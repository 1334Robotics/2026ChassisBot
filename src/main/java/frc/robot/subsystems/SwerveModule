package frc.robot.subsystems;

import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.kinematics.SwerveModulePosition;
import edu.wpi.first.math.kinematics.SwerveModuleState;
import com.revrobotics.spark.SparkMax; 
import com.revrobotics.spark.SparkLowLevel.MotorType;
import com.revrobotics.spark.SparkAbsoluteEncoder;

public class SwerveModule {
   public static final double kMaxSpeed = 4.5; 

   private final SparkMax driveMotor;
   private final SparkMax turningMotor;
   private final SparkAbsoluteEncoder turningEncoder;
   private final PIDController turningPIDController;

   public SwerveModule(int driveId, int turningId) {
      driveMotor = new SparkMax(driveId, MotorType.kBrushless);
      turningMotor = new SparkMax(turningId, MotorType.kBrushless);
      turningEncoder = turningMotor.getAbsoluteEncoder();
      turningPIDController = new PIDController(0.5, 0, 0);
      turningPIDController.enableContinuousInput(-Math.PI, Math.PI);
   }

   public SwerveModuleState getState() {
      return new SwerveModuleState(
          driveMotor.getEncoder().getVelocity(), 
          new Rotation2d(turningEncoder.getPosition())
      );
   }

   public SwerveModulePosition getPosition() {
      return new SwerveModulePosition(
          driveMotor.getEncoder().getPosition(),
          new Rotation2d(turningEncoder.getPosition())
      );
   }

   public void setDesiredState(SwerveModuleState desiredState) {
      SwerveModuleState state = SwerveModuleState.optimize(
          desiredState, 
          new Rotation2d(turningEncoder.getPosition())
      );
      driveMotor.set(state.speedMetersPerSecond / kMaxSpeed);
      double turnOutput = turningPIDController.calculate(
          turningEncoder.getPosition(), 
          state.angle.getRadians()
      );
      turningMotor.set(turnOutput);
   }
}